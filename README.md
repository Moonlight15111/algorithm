# algorithm

moonlight 练习算法与JVM相关知识的项目

#### 介绍
moonlight study algorithm project

#### 归并排序

1.  整体是递归，左边排好序 + 右边排好序 + merge 让整体上变得有序

#### 快速排序

1.  主要思想是分区Partition
2.  选定一个数（或两个）作为轴，小于等于轴的数放在数组的左边，大于轴的数放在数组的右边
3.  荷兰国旗问题

#### 堆

1.  本质上是一个完全二叉树，如果每棵子树的最大值都在顶部就是大根堆，
    如果每棵子树的最小值都在顶部就是小根堆
2.  从上到下建堆，时间复杂度为O(N*logN)，从下到上，时间复杂度为O(N) 
3.  先组成一个大根堆形式，然后把堆的最大值和堆末尾的值交换，然后在减少堆的大小之后去调整堆，
    一直周而复始，时间复杂度为O(N*logN) 

#### 前缀树

1.  字符从前到后的加到一棵多叉树上，如果没有路就新建，如有路就复用
2.  沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

#### 桶排序

1.  不基于比较的排序，使用辅助空间进行排序
2.  计数排序
3.  基数排序

#### 排序算法稳定性

		      时间复杂度	   额外空间复杂度  稳定性
1.  选择排序		O(N^2)			O(1)		无
2.  冒泡排序		O(N^2)			O(1)		有
3.  插入排序		O(N^2)			O(1)		有
4.  归并排序		O(N*logN)		O(N)		有
5.  随机快排		O(N*logN)		O(logN)		无
6.  堆排序		O(N*logN)		O(1)		无
7.  计数排序		O(N)			O(M)		有
8.  基数排序		O(N)			O(N)		有

#### 链表问题技巧

1.  使用容器(哈希表、数组等)
2.  快慢指针 

#### 二叉树

1.  先序：头左右  中序：左头右  后序：左右头  本质都是基于递归序

#### 贪心

1.  局部最功利的标准，总是做出在当前看来是最好的选择
2.  如何证明局部最功利的标准可以得到全局最优解

#### 并查集

1.  每个节点都有一条往上指的指针，节点a往上找到的根节点，叫做a所在集合的代表元
2.  查询x和y是否属于同一个集合，就是看看找到的代表元是不是一个
3.  把x和y各自所在集合的所有点合并成一个集合，
    只需要小集合的代表点挂在大集合的代表点的下方即可
    
#### 图

1.  由点的集合和边的集合构成
2.  虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达
3.  边上可能带有权值
4.  邻接表法
5.  邻接矩阵法

#### 回溯
1.模板
  ```
      void backtracking(参数) {
          if (终止条件) {
              存放结果;
              return;
          }
  
          for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
              处理节点;
              backtracking(路径，选择列表); // 递归
              回溯，撤销处理结果
          }
      }
  ```
2.位置: Permutations

#### bfprt
1. 在一个无序数组中找第K大/小，前/后K个数字
2. 流程
    ```
     五个数一组，剩下不足五个的做一组
     每个小组自己内部排序
     每个小组自己的中位数拎出来，不足五个的那组取上中点，组成一个midArr
     在midArr上面继续上述行为，直到取到唯一一个中位数
     以这个中位数为轴进行partitition，小于在左，等于在中，大于在右
     判断index在哪个区间范围上，在该区间范围重复上述所有操作
    ```
3. 位置: Bfprt

#### KMP
1. 在字符串S中是否有子串包含字符串M的，如果有返回该子串开头的位置
2. 位置: KMP

#### Manacher
1. 最长回文长度
2. 位置: Manacher

#### Morris
1. 常数空间遍历树
2. 流程
   ```
   当前节点记为cur, 一开始cur来到树的根节点
     1.如果cur无左树，cur移动到右树上
     2.如果cur有左树，找到左树最右节点，记为mostRight
       2.1.如果mostRight的右孩子为空，则将mostRight的右孩子指向cur，cur向左移动
       2.2.如果mostRight的右孩子指向cur，则将mostRight的右孩子指回空，cur向右移动
     3.如果cur为空，停止整个流程
   ```
3. 位置: Morris

#### 单调栈
1. 一个栈，从底到顶，严格递增或严格递减
2. 位置: MonotonousStack

#### 前缀和数组
1. 一维
   ```
   int[] sum = new int[nums.length];
   if (nums.length > 0) {
       sum[0] = nums[0];
       for (int i = 1; i < nums.length; i++) {
           sum[i] = sum[i - 1] + nums[i];
       }
   }
   ```
2. 二维
   ```
   二维前缀和数组中的每一个格子记录的是 以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和
   解决的是二维矩阵中的矩形区域求和问题。
   模板:
        // 预处理前缀和数组
        {
           sum = new int[n + 1][m + 1];
           for (int i = 1; i <= n; i++) {
             for (int j = 1; j <= m; j++) {
               // 当前格子(和) = 上方的格子(和) + 左边的格子(和) - 左上角的格子(和) + 当前格子(值)【和是指对应的前缀和，值是指原数组中的值】
               sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
             }
           }
        }
        求某一段区域和 [i, j] 的模板是 sum[x][y] - sum[i - 1][y] - sum[x][j - 1] + sum[i - 1][j - 1]
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
               for (int x = i; x <= n; x++) {
                  for (int y = j; y <= m; y++) {
                    int s = sum[x][y] - sum[i - 1][y] - sum[x][j - 1] + sum[i - 1][j - 1];
                    if (s <= k) {
                      ans = Math.max(ans, s);
                    }
                 }
              }
           }
        }
   ```
#### 位运算技巧
1. 位置BitBaseOp

#### 小技巧
1.  找出数字 n 是否是数字 b 的幂的一个简单方法是，n % b 只要余数为 0，就一直将 n 除以 b
2.  num & 63 ==> num % 64   ==> 只适用于 num % 2的n次方
