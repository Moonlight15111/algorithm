package com.moonlight.algorithm.mysql;

/**
 * 〈功能简述〉<br>
 * 〈〉
 *
 * @author Moonlight
 * @date 2021/5/21 9:59
 */
public class Mysql {


    public void structure() {
    /*
     * 连接器(建立/维护连接、鉴权) -> 分析器(语法、词法、参数校验) -> 查询缓存 / 优化器(使用何种索引、表连接顺序) -> 执行器
     *
     * 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。
     * 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。
     * 修改完成后，只有再新建的连接才会使用新的权限设置。
     *
     */
    }

    public void index() {
    /*
     * Mysql index:
     *   1. 为了尽量少的读磁盘，就必须在查询时尽量少的访问数据块，所以使用了 N 叉树，N 取决于数据块的大小，比如:
     *      Mysql默认一个数据页大小为 16 K，一个长整型主键bigint 大小为 8 B，再加上指向其子树的指针 6 B，那么这个
     *      N = 16 K / (8 + 6) B 约等于 1170，所以一般来说 Mysql索引B + 树 是一颗 1170 叉的树
     *      理论上来说 N 叉树的 N 是可以人工调整的，只要你能改动数据块的大小或者主键Key的大小就能影响到 N
     *   2. 回表
     *      使用普通索引查到普通索引树上的索引数据后，没办法直接获取到想要的字段值，那么就会拿着普通索引查到的主键ID值
     *      去主键索引树查一次，即基于非主键索引的查询需要多扫一次主键索引
     *   3. 页分裂(B+树叶子节点中存放的就是数据页 - page)
     *      当行主键要求将这一行插入到某个已满的数据页中时，存储引擎会开辟一个新的页，并将一部分数据挪到新的页中
     *      此时性能肯定会受到影响，且空间利用率也会降低
     */
    }

    public void count(){
    /*
     * Mysql count:
     *  MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；
     *  而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数
     *
     *  count(*):
     *    1. 有普通索引，优先走普通索引。因为Mysql是叶节点存储数据，主键索引叶节点存储的是完整的行信息，而普通索引叶节点存放的则是主键
     *    对于count(*)来说，遍历哪颗树的结果都是一样的，而普通索引因为叶节点只存储着主键信息，相对来说行密度比较大，要扫描的数据页就相对
     *    来说要少一点，可以节省一点 I/O 操作
     *  count(主键):
     *    1. InnoDB 引擎会遍历整张表，把每一行的 主键 都取出来，返回给 server 层。server 层拿到 主键 后，判断是不为空的，就按行累加。
     *  count(1):
     *    1. InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不为空的，按行累加。
     *
     *  所以count(1)理论上是要比count(主键)要快的，因为count(主键)涉及到数据行的解析、字段值的拷贝等操作
     *
     *  count(字段):
     *    1. 从记录里面一行一行的读取这个字段，判断是否为NULL，如果不为空就累加
     *    如果该字段没有索引的话，就只能选主键索引
     *
     *  count(*)、count(主键) 和 count(1) 都表示返回满足条件的结果集的总行数，
     *  而count(字段)则返回满足条件的数据行里面，字段值不为NULL的数据行个数
     *
     *  效率上: count(字段) < count(主键) < count(1) 约等于 count(*)
     */
    }

    public void orderBy() {
    /*
     * explain 的 Extra 字段中有 Using filesort 就说明需要进行排序
     *            Extra 字段中有 Using index   就说明使用了覆盖索引，所谓的覆盖索引就是说: 索引中的数据包含查询的所有字段值，
     *                                                                                     不需要再根据 Id 进行回表操作
     * 对于需要排序的 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。
     * order by:
     *  全字段排序: 把需要的字段全部放入sort_buffer中，排完序直接从内存中返回结果，不需要再回表
     *   1. 初始化 sort_buffer
     *   2. 根据条件找到第一条符合条件的数据
     *   3. 取出这条数据，并取出需要的字段的值，然后放入sort_buffer中
     *   4. 获取下一条符合条件的数据，重复3、4的过程，直到数据全部过了一遍或者没有符合条件的数据(条件字段有索引)为止
     *   5. 对 sort_buffer 中的数据按照字段 name 做快速排序
     *  rowId排序: 只取需要排序的字段和ID，排完序以后再重新根据ID回表去查实际要查的字段
     *   1. 初始化 sort_buffer
     *   2. 根据条件找到第一条符合条件的数据
     *   3. 取出这条数据，并取出排序的字段和ID，放入sort_buffer中
     *   4.  获取下一条符合条件的数据，重复3、4的过程，直到数据全部过了一遍或者没有符合条件的数据(条件字段有索引)为止
     *   5. 对 sort_buffer 中的数据按照字段 name 做快速排序
     *
     * 排序这个动作，可能在内存中完成，也有可能借助磁盘临时文件，这取决于sort_buffer是否能够装下要排序的数据
     *
     * 无条件查询order by 字段，即使字段有索引也不会走，因为走普通索引是需要回表的，那还不如直接全表扫描还能省一点普通索引扫描的时间
     * 无条件查询order by 字段 limit M，如果字段有索引且 M 较小，是可以走索引的，因为可以根据索引有序性去回表查 M 条数据，就可以终止循环了，成本比全表扫要小一点
     *
     * 总之对于Mysql来说，只要内存够用，那么就优先使用内存，尽量的减少磁盘操作
     */
    }

}
